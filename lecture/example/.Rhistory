draw = FALSE)
e2 <- eikos(Admit ~ Dept, data = UCBAdmissions,
yaxs = FALSE, xaxs = FALSE,
draw = FALSE)
# Using the gridExtra package, draw these in a single plot
grid.arrange(e1, e2, nrow = 1)
eikos(Gender ~ Dept, data = UCBAdmissions, yprobs = seq(0,1,0.25), xaxs = FALSE)
eikos(Admit ~  Gender + Dept, data = UCBAdmissions,
yaxs = FALSE, xaxs = FALSE,
lock_aspect = FALSE,
xlab_rot = 90, xvals_size = 8,
ispace = list(bottom = 15))
berkeley <- as.data.frame(UCBAdmissions)
freq <- berkeley %>%
group_by(Admit, Gender) %>%
summarise(sum = sum(Freq))
freq
mytable <- xtabs(sum ~ Admit + Gender, data = freq)
prop.table(mytable)
berkeley %>%
group_by(Admit, Gender) %>%
summarise(sum = sum(Freq))
freq
chisq.test(mytable)
mantelhaen.test(UCBAdmissions)
mytable <- xtabs(~Pclass + Survived + Sex, data = titanic_train)
library(titanic)
View(titanic_train)
mytable <- xtabs(~Pclass + Survived + Sex, data = titanic_train)
mytable
library(tidyverse)
library(tidyverse)
oddcount <- function(x){
k <- 0
for (i in seq_along(x)){
if (x[i] %% 2 == 1) k <- k+1
}
sprintf("Total number of odd numbers is %d", k)
return(k)
}
data <- seq(1:9)
oddcount(data)
x <- c()
1:length(x)
typeof(data)
rep(seq(1:10), each = 4)
findruns(,2)
data <- c(1,0,0,1,1,1,0,1,1)
findruns <- function(data, k){
n <- length(data)
runs <- NULL
for (i in 1:(n-k+1)){
if all(data[i:(i+k-1)] == 1) runs <- c(runs, i)
}
springf("There are %d runs", length(runs))
return(runs)
}
findruns(data, 2)
data <- c(1,0,0,1,1,1,0,1,1)
findruns <- function(data, k){
n <- length(data)
runs <- NULL
for (i in 1:(n-k+1)){
if all(data[i:(i+k-1)] == 1) runs <- c(runs, i)
}
springf("There are %d runs", length(runs))
return(runs)
}
findruns(data, 2)
data <- c(1,0,0,1,1,1,0,1,1)
n <- length(data)
runs <- NULL
for (i in 1:(n-2+1)){
if all(data[i:(i+k-1)] == 1) runs <- c(runs, i)
}
for (i in 1:(n-2+1)) {
if all(data[i:(i+k-1)] == 1) runs <- c(runs, i)
}
for (i in 1:(n-2+1)) {
if (all(data[i:(i+k-1)] == 1)) runs <- c(runs, i)
}
data <- c(1,0,0,1,1,1,0,1,1)
findruns <- function(data, k){
n <- length(data)
runs <- NULL
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)] == 1)) runs <- c(runs, i)
}
springf("There are %d runs", length(runs))
return(runs)
}
findruns(data, 2)
data <- c(1,0,0,1,1,1,0,1,1)
findruns <- function(data, k){
n <- length(data)
runs <- NULL
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)] == 1)) runs <- c(runs, i)
}
sprintf("There are %d runs", length(runs))
return(runs)
}
findruns(data, 2)
search()
library(MASS)
search()
detach(package:MASS, unload = TRUE)
search()
data <- as.data.frame(UCBAdmissions)
data
data %>%
group_by(Gender, Admit) %>%
summarise(n = sum(Freq))
data <- as.data.frame(UCBAdmissions)
data %>%
group_by(Gender, Admit) %>%
summarise(n = sum(Freq)) %>%
ggplot(mapping = aes(x = Gender, y = Admit, fill = n)) +
geom_col()
titanic <- tribble(
~Class, ~Sex, ~n,
"1st class", "female passengers", 144,
"1st class", "male passengers", 179,
"2nd class", "female passengers", 106,
"2nd class", "male passengers", 171,
"3rd class", "female passengers", 216,
"3rd class", "male passengers", 493
)
titanic
titanic <- tribble(
~Class, ~Sex, ~n,
"1st class", "female passengers", 144,
"1st class", "male passengers", 179,
"2nd class", "female passengers", 106,
"2nd class", "male passengers", 171,
"3rd class", "female passengers", 216,
"3rd class", "male passengers", 493
)
ggplot(data = titanic, mapping = aes(x = class, y = sex, fill = n))+
geom_col()
titanic <- tribble(
~Class, ~Sex, ~n,
"1st class", "female passengers", 144,
"1st class", "male passengers", 179,
"2nd class", "female passengers", 106,
"2nd class", "male passengers", 171,
"3rd class", "female passengers", 216,
"3rd class", "male passengers", 493
)
ggplot(data = titanic, mapping = aes(x = Class, y = Sex, fill = n))+
geom_col()
ggplot(data = titanic, mapping = aes(x = Class, y = Sex, fill = n))+
geom_col(position = "fill")
joint.dist <- prop.table(table(diamonds$cut, diamonds$color))
joint.dist
joint.dist
joint.dist <- addmargins(joint.dist)
joint.dist
prop.table(table(diamonds$cut, diamonds$color), margin = 1)
joint.dist
joint.dist[-6,-8]/joint.dist[-6,8]
prop.table(table(diamonds$cut, diamonds$color), margin = 1)
tableA <- joint.dist[-6,-8]/joint.dist[-6,8]
tableB <- prop.table(table(diamonds$cut, diamonds$color), margin = 1)
all.equal(tableA, tableB)
library(tidyverse)
library(tidyverse)
n <- 1e4
h <- .01
x <- 2
X <- rnorm(n)
kv <- ifesle(abs((X -x)/h)<=1, 1/2,0)
1/(n*h)sum(kv)
library(tidyverse)
n <- 1e4
h <- .01
x <- 2
X <- rnorm(n)
kv <- ifesle(abs((X -x)/h)<=1, 1/2,0)
1/(n*h)*sum(kv)
dnorm(2)
library(tidyverse)
n <- 1e4
h <- .01
x <- 2
X <- rnorm(n)
kv <- ifelse(abs((X -x)/h)<=1, 1/2,0)
1/(n*h)*sum(kv)
dnorm(2)
library(tidyverse)
n <- 1e4
h <- .01
x <- 2
X <- rnorm(n)
kv <- ifelse(abs((X -x)/h)<=1, 1/2,0)
1/(n*h)*sum(kv)
dnorm(2)
library(tidyverse)
n <- 1e4
h <- .01
x <- 2
X <- rnorm(n)
kv <- ifelse(abs((X -x)/h)<=1, 1/2,0)
1/(n*h)*sum(kv)
dnorm(2)
rm(list=ls())
data <- data.frame(x = rnorm(10)) %>%
mutate(x = ifelse(x<=0, NA, x))
data %>%
mutate(id = is.na(x)) %>%
arrange(desc(id))
library(ggridges)
ggplot(data = faithful, mapping = aes(x = Sepal.Width, y = Species, fill = stat(x))) +
geom_density_ridges_gradient() +
scale_fill_viridis_b(position = "C")
library(ggridges)
ggplot(data = faithful, mapping = aes(x = Sepal.Width, y = Species, fill = stat(x))) +
geom_density_ridges_gradient() +
scale_fill_viridis_b(position = "C")
ggplot(data = faithful, mapping = aes(x = Sepal.Width, y = Species, fill = stat(x))) +
geom_density_ridges_gradient() +
scale_fill_viridis_b(position = "c")
ggplot(data = faithful, mapping = aes(x = Sepal.Width, y = Species, fill = stat(x))) +
geom_density_ridges_gradient() +
scale_fill_viridis_b(pattern = "C")
ggplot(data = faithful, mapping = aes(x = Sepal.Width, y = Species, fill = stat(x))) +
geom_density_ridges_gradient() +
scale_fill_viridis_b(option = "C")
ggplot(data = iris, mapping = aes(x = Sepal.Width, y = Species, fill = stat(x))) +
geom_density_ridges_gradient() +
scale_fill_viridis_b(option = "C")
"+"(2,3)
rep(c(1,2,3,4), each = 4)
oddcount <- function(x){
k <- 0
if (i in seq_along(x)){
if (x[i]%%2 == 1) k <- k + 1
}
return(k)
}
oddcount(c(1:9))
k <- 0
if (i in seq_along(x)){
if (x[i]%%2 == 1) k <- k + 1
}
if (i in seq_along(x)) {
if (x[i]%%2 == 1) k <- k + 1
}
x[1]
x <- c(1:9)
x
x[1]
seq_along
seq_along(x)
x[2] %% 2 == 1
x[2] %% 2 == 0
oddcount <- function(x){
k <- 0
for (i in seq_along(x)) {
} (i in seq_along(x)) {
if (x[i] %% 2 == 1) k <- k + 1
}
return(k)
}
oddcount(c(1:9))
oddcount <- function(x){
k <- 0
for (i in seq_along(x)) {
if (x[i] %% 2 == 1) k <- k + 1
}
return(k)
}
oddcount(c(1:9))
data <- c(1, 0,0,1,1,1, 0, 1,1)
data
runs <- vector(length(data))
data <- c(1, 0,0,1,1,1, 0, 1,1)
runs <- vector(length(data))
runs
runs <- vector(length = length(data))
runs
data <- c(1, 0,0,1,1,1, 0, 1,1)
data
findruns  <- function(data, k){
n <- length(data)
runs <- vector(length = n)
for (i in 1:(n-k+1)){
if (all(x[i:(i+k-1)])==1) runs[i] <- i
}
return(runs[runs>0])
}
findruns(data, 2)
data <- c(1, 0,0,1,1,1, 0, 1,1)
data
findruns  <- function(data, k){
n <- length(data)
runs <- vector(length = n)
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)])==1) runs[i] <- i
}
return(runs[runs>0])
}
findruns(data, 2)
n <- length(data)
runs <- vector(length = n)
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)])==1) runs[i] <- i
}
data <- c(1, 0,0,1,1,1, 0, 1,1)
data
findruns  <- function(data, k){
n <- length(data)
runs <- rep(0, n)
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)])==1) runs[i] <- i
}
return(runs[runs>0])
}
findruns(data, 2)
n <- length(data)
runs <- rep(0, n)
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)])==1) runs[i] <- i
}
data
runs <- rep(0, n)
runs <- rep(0, n)
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)])==1) runs[i] <- i
}
runs
data <- c(1, 0,0,1,1,1, 0, 1,1)
data
findruns  <- function(data, k){
n <- length(data)
runs <- rep(0, n)
for (i in 1:(n-k+1)){
if (all(data[i:(i+k-1)]==1)) runs[i] <- i
}
runs
return(runs[runs>0])
}
findruns(data, 2)
levels(diamonds$cut)
library(tidyverse)
levels(diamonds$cut)
unique(diamonds$cut)
rm(list = ls())
library(tidyverse)
library(dplyr)
library(tidyverse)
wagedata <- read.csv("data/wage2.csv")
attach(wagedata)
setwd("~/Dropbox/02 teaching/econ5043/08github/2022s/")
wagedata <- read.csv("data/wage2.csv")
attach(wagedata)
setwd("~/Dropbox/02 teaching/econ5043/08github/2022s/lecture/example/")
wagedata <- read.csv("data/wage2.csv")
attach(wagedata)
names(wagedata)
aggregate(wage,by=list(married),FUN=mean)
library(dplyr)
results[2,1]-results[1,1]
results <-aggregate(wage,by=list(married),FUN=mean)[2]
results
results[2,1]-results[1,1]
wagedata$education <- NA
wagedata$education[educ<12] <- 1
wagedata$education[educ==12] <- 2
wagedata$education[educ>12] <- 3
attach(wagedata)
aggregate(wage,by=list(education),FUN=mean,data=wagedata)
wagedata %>%
mutate(education = case_when(
educ <12 ~ 1,
educ==12 ~ 2,
educ>12 ~ 3
)) %>%
group_by(education) %>%
summarise(mean = mean(wage,na.rm = TRUE))
aggregate(wage,by=list(education, married),FUN=mean,data=wagedata)
data <- data.frame(x = c(1:3)) %>%
mutate(y = 2*x + rnorm(3))
data
data <- data.frame(x = c(1:3)) %>%
mutate(y = 2*x + rnorm(3))
beta = 1
data$yhat   <- beta*data$x
data
data$error  <- data$y-data$yhat
data
data$error2 <- data$error^2
data
mse <- mean(data$error2)
mse
beta = 2
data$yhat   <- beta*data$x
data$error  <- data$y-data$yhat
data$error2 <- data$error^2
mse <- mean(data$error2)
mse
mymse <- function(beta){
# Step 1. Generate prediction
data$yhat   <- beta*data$x
data$error  <- data$y-data$yhat
data$error2 <- data$error^2
mse <- mean(data$error2)
return(mse)
}
seq(1,3,.01)
all.mse <- sapply(seq(1,3,.01), mymse)
results <- data.frame(
beta = seq(1,3,.01),
mse = all.mse)
View(results)
ggplot(data = results, mapping = aes(x = beta, y = mse)) +
geom_point()
index <- which(results$mse==min(results$mse))
index
results$beta[index]
# Generate artificial data with three data points
data <- data.frame(x = c(1:3)) %>%
mutate(y = 2*x )
# Program a function to calculate mean squared error
# for a given beta coefficient
mymse <- function(beta){
# Step 1. Generate prediction
data$yhat   <- beta*data$x
data$error  <- data$y-data$yhat
data$error2 <- data$error^2
mse <- mean(data$error2)
return(mse)
}
# Try all possible beta values from 1 to 3
all.mse <- sapply(seq(1,3,.01), mymse)
results <- data.frame(
beta = seq(1,3,.01),
mse = all.mse)
# Plot the relationship
ggplot(data = results, mapping = aes(x = beta, y = mse)) +
geom_point()
# Find out the optimal value
# find out the position of the smallest MSE
index <- which(results$mse==min(results$mse))
index
# find out the corresponding beta value
results$beta[index]
# This program illustrate the grid search method to numerical
# optimization by solving the linear regression problem.
library(tidyverse)
# Generate artificial data with three data points
data <- data.frame(x = c(1:1000)) %>%
mutate(y = 2*x + rnorm(n()))
# Program a function to calculate mean squared error
# for a given beta coefficient
mymse <- function(beta){
# Step 1. Generate prediction
data$yhat   <- beta*data$x
data$error  <- data$y-data$yhat
data$error2 <- data$error^2
mse <- mean(data$error2)
return(mse)
}
# Try all possible beta values from 1 to 3
all.mse <- sapply(seq(1,3,.01), mymse)
results <- data.frame(
beta = seq(1,3,.01),
mse = all.mse)
# Plot the relationship
ggplot(data = results, mapping = aes(x = beta, y = mse)) +
geom_point()
# Find out the optimal value
# find out the position of the smallest MSE
index <- which(results$mse==min(results$mse))
index
# find out the corresponding beta value
results$beta[index]
# Interpretation: Of course, due to sampling errors, we do not necessarily
# obtain the true coefficient. To see the impact of the sampling errors,
# we can remove the random part in our data generating process, we will
# see that we can now attain the true beta.
lm(y ~ x, data = data)
wagedata <- read.csv("data/wage2.csv")
# CEF for each category
aggregate(wage,by=list(married),FUN=mean)
results <-aggregate(wage,by=list(married),FUN=mean)[2]
results[2,1]-results[1,1]
lm(wage ~ factor(married)+0, data=wagedata)
model <- lm(wage ~ married)
summary(model)
lm(wage ~ married)
lm(wage ~ factor(married)+0, data=wagedata)
results <- lm(wage ~ factor(married)+0, data=wagedata)
# Linear Regression without intercept
summary(results)
wagedata <- read.csv("data/wage2.csv")
wagedata$education <- NA
wagedata$education[educ<12] <- 1
wagedata$education[educ==12] <- 2
wagedata$education[educ>12] <- 3
attach(wagedata)
aggregate(wage,by=list(education),FUN=mean,data=wagedata)
results <- aggregate(wage,by=list(education),FUN=mean,data=wagedata)
results
results[2,2]-results[1,2]
results[3,2]-results[2,2]
# Linear Regression without intercept
results <- lm(wage~factor(education)+0,data=wagedata)
summary(results)
# Linear Regression without intercept
results <- lm(wage~factor(education),data=wagedata)
summary(results)
